# 对象的存活

在堆中存放着几乎所有Java对象的实例，垃圾回收之前的第一件事就是判断对象是否存活。

## 引用计数算法 🔢

引用计数算法如其名，当前对象如果有一个地方引用，则引用计数+1，引用失效的时候则-1，当引用计数为0时，即为判断该对象已“死亡”（在内存中已无作用）的依据。

- ❌ 弊端： 无法解决两个对象相互引用的问题，例如
``` java
A.obj = B;
B.obj = A;

A=null;
B=null;
```
如果用引用计数算法来判断其存亡状态，那么A和B永远都属于存活状态。

## 可达性分析算法 🔎

通过GC Roots的对象为起点，向下搜索，能到达的对象为不可回收对象，不能到达的对象为需要回收的对象。在不可到达的对象中，也并非所有对象都会被回收，还需要经过再次标记过程，才确定是否真正回收。

> 二次标记：通过对象的finalize()方法确定最终是否回收，此方法一般不用到，我们也不会在对象的这种状态下做太多功夫，所以可忽略。

**GC Roots 一般为一下几个部分中的对象**

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI（即一般说的Native方法）引用的对象


## Java中的几种引用

在JDK1.2之后，Java对引用的概念进行了扩充，可以将引用分为以下四类：

- 🔗 强引用（Strong Reference)

强引用就是代码中常见的对象引用，垃圾回收器在面对有强引用的对象时，不会对其进行回收。

- 🔗 软引用（Soft Reference)

软引用指的是存在对象关联的，但不是必须的引用，有软引用关联的对象会在**<font color=red>内存不足时进行回收</font>**。在Java中可以使用```java.lang.ref.SoftReference```实现

- 🔗 弱引用（Weak Reference)

弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，**<font color=red>无论内存是否充足，都会回收被弱引用关联的对象</font>**。在Java中可以使用```java.lang.ref.WeakReference```实现

- 🔗 虚引用（Phantom Reference)

⁉️ 这种引用类型有什么用？？待思考

> 虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。
要注意的是，虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

这四种引用从上到下，依次减弱
